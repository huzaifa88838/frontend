const casinoSnapsMixin = {
    data: function() {
        return {
            wsc: null,
            sToken: null
        }
    },
    created: function() {},
    computed: {
        isSignalRConnected: function() {
            return this.wsc !== null && this.wsc.state === signalR.HubConnectionState.Connected
        }
    },
    methods: {
        Connect: function() {
            const self = this;
            self.wsc = (new signalR.HubConnectionBuilder).withUrl(self.casinoUrl, {
                accessTokenFactory: () => self.AccessTokenProvider()
            }).withAutomaticReconnect({
                nextRetryDelayInMilliseconds: retryContext => {
                    return retryContext.elapsedMilliseconds < 36e5 ? retryContext.previousRetryCount === 0 ? 0 : retryContext.previousRetryCount === 1 ? 2e3 : retryContext.previousRetryCount < 10 ? 5e3 : 1e4 : null
                }
            }).configureLogging(signalR.LogLevel.Error).build();
            self.wsc.onreconnected( () => {
                self.SubscribeChannel()
            }
            );
            if (ControllerName == "BetProGames") {
                self.wsc.on("ReceiveTPSnapshot", data => {
                    self.RenderSnapshot(data)
                }
                );
                self.wsc.on("ReceiveShortResult", data => {
                    self.RenderShortResults(data)
                }
                );
                self.wsc.on("ReceiveCashoutNotification", data => {
                    self.Toastertoshow(data.message, 1)
                }
                );
                self.wsc.on("ReceiveCommunityOrder", data => {
                    self.UpdateLuckyPlayers(data)
                }
                );
                self.wsc.on("ReceiveTPSPrice", data => {
                    self.SetCrashGamePrice(data)
                }
                );
                self.wsc.on("ReceiveGroupMemberCount", count => {
                    self.UpdateConnections(count)
                }
                )
            } else
                self.wsc.on("ReceiveBFSnapshot", data => {
                    self.RenderSnapshot(data)
                }
                );
            self.wsc.on("Pong", () => {
                self.Pong()
            }
            );
            self.wsc.on("ReceiveOrders", Data => {
                self.RenderOrders(Data)
            }
            );
            self.wsc.on("CashoutAck", data => {
                self.CashoutAck(data)
            }
            );
            self.wsc.on("OrderAck", data => {
                self.OrderAck(data)
            }
            );
            self.wsc.on("OrderErr", data => {
                self.OrderErrored(data)
            }
            );
            this.StartSignalR()
        },
        AccessTokenProvider: function() {
            return this.sToken
        },
        StartSignalR: function() {
            if (this.wsc.state === signalR.HubConnectionState.Disconnected) {
                let self = this;
                this.wsc.start().then(function() {
                    self.SubscribeChannel()
                }).catch(function() {
                    setTimeout( () => self.StartSignalR(), 3e3)
                })
            }
        },
        SubscribeChannel: function() {
            const self = this;
            ControllerName == "BetProGames" ? self.wsc.invoke("SubscribeTPChannel", self.channelId) : self.wsc.invoke("SubscribeBFChannel", self.channelId)
        },
        RenderSnapshot: function(data) {
            data != null && this.SetPositions(data)
        },
        RenderOrders: function(data) {
            this.ExMatched = data.orders.reverse();
            this.positions = data.position;
            this.SetSignalRposition();
            this.EnableCashout(data.orders)
        },
        RenderShortResults: function(Results) {
            this.shortresults = Results
        }
    }
}
  , crashGameMixin = {
    data: function() {
        return {
            clientSeed: null,
            crashGamePrice: null,
            gameState: GameState.CLOSED,
            runnersCount: 2,
            betActions: [],
            AviatorLUckyPlayers: [],
            currencyRate: 1,
            autoPriceIntvl: null,
            latency: 0,
            pingTime: 0,
            funfactvalue: "The best day to play is.. Everyday!"
        }
    },
    created: function() {
        let self = this;
        this.clientSeed = this.GetClientSeed();
        let defBetSize = 0
          , defBetSizeEl = document.querySelector("#defaultBetSize");
        defBetSizeEl != null && (defBetSize = defBetSizeEl.value);
        this.currencyRate = 1;
        let currencyEl = document.querySelector("#userCurrencyRate");
        currencyEl != null && (this.currencyRate = currencyEl.value);
        for (let i = 1; i <= this.runnersCount; i++)
            this.betActions.push({
                id: i,
                title: "Next",
                action: "bet",
                betSize: parseInt(defBetSize),
                betState: OrderState.EMPTY,
                autoBet: !1,
                autoCashout: !1,
                autoCashoutPrice: 1.1,
                visible: !0,
                isPartialCashoutDisabled: !1,
                BlastPwinloseamount: 0,
                cssClasses: {
                    btn: !0,
                    "btn-success": !0,
                    "btn-info": !1
                },
                winloseamount: 0
            });
        setInterval( () => {
            self.PingTest()
        }
        , 5e3);
        window.addEventListener("resize", this.resizeCanvas)
    },
    computed: {
        isOrderEnqueued: function() {
            return this.betActions.find(x => x.betState === OrderState.QUEUED) != null
        },
        isOrderSubmitted: function() {
            return this.betActions.find(x => x.betState === OrderState.SUBMITTED) != null
        },
        displayPrice: function() {
            return this.crashGamePrice == null ? " - " : (exgameid == 9040 && this.RunningCanvas(),
            this.crashGamePrice.toFixed(2) + " x")
        }
    },
    watch: {
        timeLeft: function(newVal) {
            (this.snapshot.channel.status !== 2 && this.betActions.forEach(element => {
                element.title != "Cashout" && (element.cssClasses.disabled = !1,
                element.cssClasses.EnablePointers = !1)
            }
            ),
            this.snapshot.channel.status === 1) && (newVal <= 3 && this.betActions.forEach(element => {
                element.title == "Place" && (element.cssClasses.disabled = !0,
                element.cssClasses.EnablePointers = !0)
            }
            ),
            newVal > 4 && newVal <= 5 && this.betActions.forEach(function(element) {
                element.autoBet && (element.betState = OrderState.QUEUED);
                element.winloseamount = 0
            }),
            newVal > 2 && newVal <= 4 && this.SubmitOrdersAlt())
        },
        snapshot: function(newVal, oldVal) {
            if (newVal != null && newVal.channel != null && newVal.channel != undefined) {
                let prevPrice = 1.1;
                oldVal != null && oldVal.channel != null && oldVal.channel.game != null && (prevPrice = oldVal.channel.game.gameData[0].totalValue);
                newVal.channel.game.gameData[0].totalValue != null && newVal.channel.game.gameData[0].totalValue != prevPrice && this.UpdateCrashGamePrice(newVal.channel.game.gameData[0].totalValue);
                switch (newVal.channel.status) {
                case 1:
                    this.gameState = GameState.OPEN;
                    break;
                case 2:
                    this.gameState = GameState.CASHOUT;
                    break;
                case 3:
                case 4:
                    this.gameState = GameState.CLOSED
                }
                if (this.gameState == GameState.CASHOUT && this.betActions.forEach(element => {
                    element.cssClasses.disabled = !1,
                    element.cssClasses.EnablePointers = !1
                }
                ),
                this.gameState == GameState.OPEN) {
                    this.AviatorLUckyPlayers = [];
                    for (let i = 0; i < this.runnersCount; i++)
                        this.betActions[i].betState === OrderState.SUBMITTED && this.ResetOrder(this.betActions[i].id);
                    this.betActions.forEach(function(element) {
                        element.title == "Next" && (element.title = "Place");
                        element.visible = !0
                    })
                }
                if (this.gameState === GameState.CASHOUT && this.betActions.forEach(function(element) {
                    element.title == "Place" && (element.title = "Next");
                    element.visible = !0
                }),
                this.betActions.length > 0 && this.gameState === GameState.CLOSED) {
                    for (let i = 0; i < this.runnersCount; i++)
                        this.betActions[i].betState === OrderState.SUBMITTED && this.ResetOrder(this.betActions[i].id);
                    this.SetFunFact()
                }
                this.UpdateAviatorAnimation(newVal.channel.status)
            }
        },
        crashGamePrice: function(newVal) {
            for (let i = 0; i < this.runnersCount; i++)
                this.betActions[i].autoCashout && newVal >= this.betActions[i].autoCashoutPrice && this.betActions[i].betState == OrderState.SUBMITTED && (this.Cashout(this.betActions[i].id),
                this.Trace("Auto cashout triggered # " + this.betActions[i].id))
        }
    },
    methods: {
        SetCrashGamePrice: function(priceData) {
            this.UpdateCrashGamePrice(priceData.price);
            this.UpdateRunnersWinloss()
        },
        UpdateCrashGamePrice: function(price) {
            this.crashGamePrice = parseFloat(price)
        },
        UpdateRunnersWinloss: function() {
            for (let i = 0; i < this.runnersCount; i++)
                this.betActions[i].betState === OrderState.SUBMITTED && (this.betActions[i].winloseamount = (this.betActions[i].betSize * parseFloat(this.crashGamePrice) - this.betActions[i].betSize).toFixed(),
                exgameid == "9023" && (this.betActions[i].isPartialCashoutDisabled ? this.betActions[i].winloseamount = (this.betActions[i].winloseamount / 2).toFixed() : this.betActions[i].BlastPwinloseamount = (this.betActions[i].winloseamount / 2).toFixed()))
        },
        BetAction: function(key, selId) {
            key == "bet" ? this.EnqueueOrder(selId) : key == "cancel" ? this.CancelOrder(selId) : key == "cashout" && this.Cashout(selId)
        },
        EnqueueOrder: function(selectionId) {
            let rn = this.betActions.find(x => x.id === selectionId);
            rn.betState = OrderState.QUEUED;
            rn.title = "Cancel";
            rn.action = "cancel";
            rn.cssClasses["btn-success"] = !1;
            rn.cssClasses["btn-info"] = !0
        },
        CancelOrder: function(selectionId) {
            let rn = this.betActions.find(x => x.id === selectionId);
            rn.betState = OrderState.EMPTY;
            rn.title = "Next";
            rn.action = "bet";
            rn.cssClasses["btn-success"] = !0;
            rn.cssClasses["btn-info"] = !1
        },
        ResetOrder: function(selId) {
            const self = this;
            let rn = this.betActions.find(x => x.id === selId);
            rn.winloseamount = 0;
            rn.betState = OrderState.EMPTY;
            rn.isPartialCashoutDisabled = !1;
            rn.BlastPwinloseamount = 0;
            rn.title = "Next";
            rn.action = "bet";
            rn.cssClasses["btn-success"] = !0;
            rn.cssClasses["btn-info"] = !1;
            rn.cssClasses["btn-warning"] = !1;
            rn.cssClasses.disabled = !1;
            rn.cssClasses.EnablePointers = !1;
            window.removeEventListener("beforeunload", self.BeforeUnloadHandler)
        },
        SubmitOrder: function(selectionId) {
            const self = this;
            let rn = this.betActions.find(x => x.id === selectionId);
            rn != null ? (rn.betState = OrderState.SUBMITTED,
            rn.title = "Cashout",
            rn.action = "cashout",
            rn.cssClasses["btn-success"] = !1,
            rn.cssClasses["btn-info"] = !1,
            rn.cssClasses["btn-warning"] = !0,
            self.timeLeft > 0 ? (rn.cssClasses.disabled = !0,
            rn.cssClasses.EnablePointers = !0) : (rn.cssClasses.disabled = !1,
            rn.cssClasses.EnablePointers = !1)) : console.error("not found: " + selectionId)
        },
        SubmitOrders: function() {
            if (this.isOrderEnqueued) {
                const self = this;
                var qs = "/api/v2/Orders/game/Aviator/" + exgameid;
                exgameid == "9023" && (qs = "/api/v2/Orders/game/" + exgameid);
                for (let i = 0; i < this.runnersCount; i++)
                    this.betActions[i].betState === OrderState.QUEUED && (this.betActions[i].betState = OrderState.PROCESSING);
                let orders = self.CreateOrders();
                if (orders.length === 0) {
                    this.ResetOrder(1);
                    this.ResetOrder(2);
                    return
                }
                let dataToSend = orders;
                exgameid == "9023" && (dataToSend = orders[0]);
                $.ajax({
                    type: "POST",
                    url: qs,
                    data: JSON.stringify(dataToSend),
                    contentType: "application/json; charset=utf-8",
                    success: function(result) {
                        window.addEventListener("beforeunload", self.BeforeUnloadHandler);
                        let successOrders = 0;
                        if (exgameid == "9023")
                            ++successOrders,
                            self.SubmitOrder(result.selectionId);
                        else
                            for (const element of result)
                                if (element.success)
                                    ++successOrders,
                                    self.SubmitOrder(element.order.selectionId);
                                else {
                                    let msg = "Order #" + element.orderRequest.selectionId + " failed: " + element.message;
                                    self.Toastertoshow(msg, 2);
                                    self.ResetOrder(element.orderRequest.selectionId)
                                }
                        if (successOrders > 0) {
                            let msg = successOrders + " orders placed";
                            self.Toastertoshow(msg, 1)
                        }
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        console.error(errorThrown);
                        errorThrown == "Unauthorized" ? (self.Toastertoshow(errorThrown + " Login Again", 2),
                        setTimeout( () => {
                            location.reload()
                        }
                        , 2e3)) : jqXHR.responseJSON && jqXHR.responseJSON.title && self.Toastertoshow(jqXHR.responseJSON.title, 2);
                        for (let i = 0; i < self.runnersCount; i++)
                            (self.betActions[i].betState === OrderState.SUBMITTED || self.betActions[i].betState === OrderState.PROCESSING) && self.ResetOrder(self.betActions[i].id)
                    },
                    complete: function() {}
                })
            }
        },
        SubmitOrdersAlt: function() {
            if (this.isOrderEnqueued) {
                for (let i = 0; i < this.runnersCount; i++)
                    this.betActions[i].betState === OrderState.QUEUED && (this.betActions[i].betState = OrderState.PROCESSING);
                let orders = this.CreateOrders();
                if (orders.length === 0) {
                    this.ResetOrder(1);
                    this.ResetOrder(2);
                    return
                }
                this.wsc.invoke("PlaceOrder", orders);
                this.Trace("Orders sent to message bus")
            }
        },
        OrderAck: function(data) {
            this.Trace(data);
            window.addEventListener("beforeunload", this.BeforeUnloadHandler);
            this.OrderAccepted();
            for (let i = 0; i < this.runnersCount; i++)
                if (this.betActions[i].betState === OrderState.PROCESSING) {
                    this.SubmitOrder(data.selectionId);
                    return
                }
        },
        OrderAccepted: function() {
            toastr.success("Order placed")
        },
        OrderErrored: function(data) {
            this.ResetOrder(data.selectionId);
            toastr.error(data.error)
        },
        EnableCashout: function(orders) {
            const self = this;
            for (const element of orders)
                self.SubmitOrder(element.selection)
        },
        Cashout: function(selectionId) {
            const cashoutRequest = {
                GameId: exgameid,
                MarketId: this.currentMarketId,
                Price: this.crashGamePrice,
                SelectionId: parseInt(selectionId),
                IsPartial: !1
            };
            this.wsc.invoke("CashOut", cashoutRequest)
        },
        CashoutPartial: function(selectionId) {
            const cashoutRequest = {
                GameId: exgameid,
                MarketId: this.currentMarketId,
                Price: this.crashGamePrice,
                SelectionId: parseInt(selectionId),
                IsPartial: !0
            };
            this.wsc.invoke("CashOut", cashoutRequest)
        },
        CashoutAck: function(data) {
            data.isPartial ? this.betActions[0].isPartialCashoutDisabled = !0 : this.ResetOrder(data.selectionId)
        },
        CreateOrders: function() {
            let orders = [];
            for (let i = 0; i < this.runnersCount; i++)
                if (this.betActions[i].betState === OrderState.PROCESSING) {
                    let o = this.CreateOrder(this.betActions[i].id);
                    o != null && orders.push(o)
                }
            return orders
        },
        CreateOrder: function(selectionId) {
            let betSize = this.betActions[selectionId - 1].betSize;
            if (betSize == undefined || betSize == "")
                return null;
            return {
                price: 1,
                side: "b",
                marketId: this.currentMarketId,
                channelId: exgameid,
                identity: GetDeviceIdentity(),
                selection: selectionId,
                clientSeed: this.clientSeed.toString(),
                size: parseInt(betSize)
            }
        },
        hasOrderInQueue: function(selectionId) {
            return this.betActions.find(x => x.id === selectionId).betState === OrderState.QUEUED
        },
        hasSubmittedOrder: function(selectionId) {
            return this.betActions.find(x => x.id === selectionId).betState === OrderState.SUBMITTED
        },
        isCashoutAvailable: function(selectionId) {
            return this.gameState === GameState.CASHOUT && this.hasSubmittedOrder(selectionId)
        },
        AutoBetSlider: function(id) {
            this[`isAutoBet${id}`] = !this[`isAutoBet${id}`]
        },
        sliderBarVisibility: function(id) {
            var sliderDiv = document.getElementById("sliderDiv" + id);
            this[`isAutoCashout${id}`] = !this[`isAutoCashout${id}`];
            document.getElementById("switch2" + id).checked ? (isAutoCashout = !0,
            sliderDiv.style.display = "block") : (isAutoCashout = !1,
            sliderDiv.style.display = "none")
        },
        updateSliderValue: function(id) {
            var slider = document.getElementById("slider" + id)
              , sliderValue = document.getElementById("sliderValue" + id);
            sliderValue.innerText = slider.value
        },
        getAutoCashoutPrice: function(id) {
            return this[`autoCashoutPrice${id}`]
        },
        getrunnersize: function(id) {
            return this[`BetSize${id}`]
        },
        setAutoCashoutPrice: function(id, value) {
            let parsedValue = parseFloat(value);
            parsedValue < 50 && (parsedValue = parsedValue + .01);
            parsedValue = parseFloat(parsedValue.toFixed(2));
            this.$set(this, `autoCashoutPrice${id}`, parseFloat(parsedValue))
        },
        handleManualInput: function(id, value) {
            let parsedValue = parseFloat(value);
            isNaN(parsedValue) || (parsedValue = parseFloat(parsedValue.toFixed(2)),
            this.$set(this, `autoCashoutPrice${id}`, parseFloat(parsedValue)))
        },
        handleManualSizes: function(id, value) {
            this.$set(this, `BetSize${id}`, parseInt(value))
        },
        handleManualSizesinc: function(id, value) {
            let parsed = this[`BetSize${id}`];
            parsed = parsed + parseInt(value);
            this.$set(this, `BetSize${id}`, parseInt(parsed))
        },
        GetClientSeed: function() {
            const seeds = new Uint32Array(1);
            return window.crypto.getRandomValues(seeds),
            seeds[0]
        },
        IncrementPrice: function(selectionId) {
            this.betActions[selectionId - 1].autoCashoutPrice = +(parseFloat(this.betActions[selectionId - 1].autoCashoutPrice) + .01).toFixed(2)
        },
        DecrementPrice: function(selectionId) {
            let rn = this.betActions.find(x => x.id === selectionId);
            rn.autoCashoutPrice > 1.1 && (rn.autoCashoutPrice = +(rn.autoCashoutPrice - .01).toFixed(2))
        },
        IncrementSize: function(selectionId, amount) {
            let rn = this.betActions.find(x => x.id === selectionId);
            rn.betSize = parseInt(rn.betSize) + parseInt(amount)
        },
        SetSize: function(selectionId, amount) {
            let rn = this.betActions.find(x => x.id === selectionId);
            rn.betSize = parseInt(amount)
        },
        DecrementSize: function(selectionId, amount) {
            let rn = this.betActions.find(x => x.id === selectionId);
            rn.betSize - amount > 0 && (rn.betSize -= amount)
        },
        UpdateLuckyPlayers: function(data) {
            let self = this;
            if (data.size = +(data.size / self.currencyRate).toFixed(2),
            data.winLose = +(data.winLose / self.currencyRate).toFixed(2),
            data.price === 0 && data.winLose === 0)
                self.AviatorLUckyPlayers.push(data),
                self.SortCommunityOrders();
            else {
                let m = _.find(self.AviatorLUckyPlayers, function(item) {
                    return item.userId === data.userId && item.size == data.size && item.winLose == 0
                });
                if (exgameid == "9023" && (m == null || m == undefined)) {
                    let n = _.find(self.AviatorLUckyPlayers, function(item) {
                        return item.userId === data.userId && item.size == data.size
                    });
                    n !== null && n !== undefined && (n.winLose = n.winLose + data.winLose)
                } else
                    m !== null && m !== undefined && (m.price = data.price,
                    m.size = data.size,
                    m.winLose = data.winLose)
            }
        },
        SortCommunityOrders: function() {
            this.AviatorLUckyPlayers.sort( (x, y) => y.size - x.size);
            let usernames = _.uniq(this.AviatorLUckyPlayers.map(x => x.username));
            for (let i = 0; i < this.AviatorLUckyPlayers.length; i++)
                this.AviatorLUckyPlayers[i].rank = usernames.indexOf(this.AviatorLUckyPlayers[i].username) + 1;
            this.AviatorLUckyPlayers.sort( (x, y) => x.rank - y.rank)
        },
        IncrementPriceCont: function(selectionId, event) {
            event && event.preventDefault();
            let self = this;
            self.IncrementPrice(selectionId);
            self.autoPriceIntvl != null && clearInterval(self.autoPriceIntvl);
            self.autoPriceIntvl = setInterval( () => {
                let rn = self.betActions.find(x => x.id === selectionId);
                rn.autoCashoutPrice = +(rn.autoCashoutPrice + .01).toFixed(2)
            }
            , 100)
        },
        validateInput: function(rnr) {
            rnr.autoCashoutPrice === "" || rnr.autoCashoutPrice >= 1.1
        },
        validateMinValue: function(rnr) {
            (rnr.autoCashoutPrice === "" || rnr.autoCashoutPrice < 1.1) && (rnr.autoCashoutPrice = 1.1)
        },
        StopPriceIncrement: function() {
            clearInterval(this.autoPriceIntvl)
        },
        DecrementPriceCont: function(selectionId, event) {
            event && event.preventDefault();
            let self = this;
            self.DecrementPrice(selectionId);
            self.autoPriceIntvl = setInterval( () => {
                let rn = self.betActions.find(x => x.id === selectionId);
                rn.autoCashoutPrice <= 1.1 ? clearInterval(self.autoPriceIntvl) : rn.autoCashoutPrice = +(rn.autoCashoutPrice - .01).toFixed(2)
            }
            , 100)
        },
        ImagesLoaded: function() {
            this.UpdateAviatorAnimation(this.snapshot.channel.status)
        },
        UpdateAviatorAnimation: function(LatestState) {
            const scrollContent = document.querySelector(".scroll-contentaviator")
              , centerImage = document.getElementById("centerImageaviator")
              , Propeler = document.getElementById("animated-svg")
              , overlayblast = document.getElementById("overlayAVIA")
              , planeimage = document.getElementById("planeimage")
              , toshakecontent = document.getElementById("toshakecontent");
            if (centerImage != null) {
                let isRotating = !1;
                if (LatestState == 1 && (centerImage.classList.remove("greyed-out", "spin-and-shrink", "shrink-rotate"),
                scrollContent.classList.remove("slow-scroll"),
                scrollContent.style.animation = "none",
                scrollContent.offsetHeight,
                scrollContent.style.animation = null,
                scrollContent.style.animationPlayState = "paused",
                typeof Propeler != undefined && Propeler != null && (Propeler.style.animationPlayState = "paused",
                Propeler.classList.remove("animation-div")),
                planeimage.classList.remove("greyed-out"),
                toshakecontent.classList.remove("shakescreen")),
                LatestState == 2 && (Propeler.classList.add("animation-div"),
                Propeler.style.animationPlayState = "running",
                centerImage.classList.add("Moveingrightleft"),
                scrollContent.style.animation = "none",
                scrollContent.offsetHeight,
                scrollContent.style.animation = null,
                scrollContent.style.animationPlayState = "running",
                centerImage.style.animation = "",
                isRotating = !1),
                LatestState == 3 && (toshakecontent.classList.add("shakescreen"),
                overlayblast.style.display = "flex",
                this.crashGamePrice > 1.06 && centerImage.classList.add("shrink-rotate"),
                planeimage.classList.add("greyed-out"),
                setTimeout(function() {
                    overlayblast.style.display = "none"
                }, 800),
                scrollContent.classList.contains("slow-scroll") || (scrollContent.style.animationPlayState = "paused",
                scrollContent.classList.add("slow-scroll"),
                scrollContent.style.animationPlayState = "running"),
                typeof Propeler != undefined && Propeler != null && (Propeler.style.animationPlayState = "running"),
                isRotating || (centerImage.classList.remove("Moveingrightleft"),
                centerImage.style.animation = null,
                isRotating = !0),
                !isBgMuted)) {
                    const crashSound = document.getElementById("crashSound");
                    crashSound && crashSound.paused && !document.hidden && (crashSound.volume = .4,
                    crashSound.play().catch(error => {
                        console.error("Error playing the Crash audio:", error)
                    }
                    ))
                }
                LatestState == 4 && (scrollContent.style.animationPlayState = "paused")
            }
            if (exgameid == 9040 && (LatestState == 1 && this.resetPlaneToStart(),
            LatestState == 2 && this.startAnimation(),
            (LatestState == 3 || LatestState == 4) && (this.crashPlane(),
            LatestState == 3 && !isBgMuted))) {
                const crashSound = document.getElementById("crashSound");
                crashSound && crashSound.paused && !document.hidden && (crashSound.volume = .4,
                crashSound.play().catch(error => {
                    console.error("Error playing the Crash audio:", error)
                }
                ))
            }
        },
        PingTest: function() {
            this.pingTime = (new Date).getTime();
            this.wsc != null && this.wsc.invoke("Ping")
        },
        UpdateConnections: function(count) {
            count = (isNaN(count) ? 0 : Number(count)) + 50;
            let el = document.getElementById("UsersCount");
            el !== null && (el.innerText = count)
        },
        Pong: function() {
            this.latency = (new Date).getTime() - this.pingTime;
            let strength = this.latency;
            const bars = document.querySelectorAll(".AVI-icon__signal-strength span");
            let barsToFill;
            barsToFill = strength >= 0 && strength <= 200 ? 4 : strength > 200 && strength <= 400 ? 3 : strength > 400 && strength <= 800 ? 2 : 1;
            bars.forEach( (bar, index) => {
                bar.style.backgroundColor = index < barsToFill ? barsToFill <= 2 ? "#FF0000" : "#00FF00" : "#ccc"
            }
            )
        },
        SetFunFact: function() {
            const stringsArray = ["Sometimes you lose, sometimes you win. Try again!", "A player cashed out 4.5 lakhs from a single bet.", "The best day to play is.. Every day!", "The highest consecutive days played by a player is 12.", "Chances of winning are high when you play more.", "The average bet per round is 500.", "Inviting your friend doubles your combined chances of winning."]
              , randomIndex = Math.floor(Math.random() * stringsArray.length)
              , selectedString = stringsArray[randomIndex];
            this.funfactvalue = selectedString
        },
        resizeCanvas: function() {
            try {
                canvas = document.getElementById("animationCanvas");
                ctx = canvas.getContext("2d");
                planeGif = document.getElementById("planeGif");
                const container = document.querySelector(".scroll-containeraviator");
                container && (canvas.width = container.clientWidth,
                canvas.height = container.clientHeight);
                this.updatePlaneStartPosition();
                this.drawStaticScene()
            } catch (error) {
                setTimeout( () => this.resizeCanvas(), 1e3)
            }
        },
        updatePlaneStartPosition: function() {
            const {height: planeHeight} = this.getPlaneDimensions()
              , mobileHorizontalOffset = window.innerWidth < 768 ? 20 : 0;
            planeStartX = .1 * canvas.width + mobileHorizontalOffset;
            planeStopX = canvas.width * .8;
            window.innerWidth < 768 ? (planeEndY = canvas.height * .4,
            planeStopX = canvas.width * .7,
            planeStartY = canvas.height - planeHeight + 16) : (planeEndY = canvas.height / 3,
            planeStartY = canvas.height - planeHeight + 15);
            currentX = planeStartX;
            currentY = planeStartY
        },
        getPlaneDimensions: function() {
            const baseWidth = canvas.width * .11
              , baseHeight = canvas.height * .14;
            return window.innerWidth < 768 ? {
                width: baseWidth * 2,
                height: baseHeight * 1
            } : {
                width: baseWidth,
                height: baseHeight
            }
        },
        startAnimation: function() {
            canvas != "" && planeGif && (animationId !== undefined && animationId || (startTime = null,
            reachedCenter = !1,
            isCrashed = !1,
            planeGif.style.display = "block",
            cancelAnimationFrame(animationId),
            animationId = requestAnimationFrame(this.animate)))
        },
        animate: function(timestamp) {
            startTime || (startTime = timestamp);
            const elapsed = timestamp - startTime
              , progress = Math.min(elapsed / duration, 1);
            this.drawPlane(progress, elapsed);
            (progress < 1 || reachedCenter) && !isCrashed ? animationId = requestAnimationFrame(this.animate) : isCrashed && (animationId = requestAnimationFrame(this.animate))
        },
        drawPlane: function(progress, elapsedTime) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let oscillatingOffsetY = 0
              , oscillatingOffsetX = 0;
            if (progress >= 1 && (reachedCenter = !0),
            (this.snapshot.channel.status == 3 || this.snapshot.channel.status == 4) && (isCrashed = !0),
            this.drawRotatingBackground(),
            this.drawCenteredGradientBackground(),
            reachedCenter && !isCrashed) {
                const oscillationAmplitude = canvas.height * .1
                  , oscillationStartTime = Math.max(elapsedTime - duration, 0)
                  , easeFactor = Math.min(oscillationStartTime / 2e3, 1)
                  , effectiveAmplitude = oscillationAmplitude * easeFactor;
                oscillatingOffsetY = effectiveAmplitude * Math.sin(.001 * elapsedTime);
                oscillatingOffsetX = (oscillatingOffsetY < 0 ? -1 : 1) * Math.abs(oscillatingOffsetY * 1.5)
            }
            if (this.drawDynamicLines(progress, oscillatingOffsetY, oscillatingOffsetX),
            this.drawMovingDots(),
            this.drawVerticalDots(),
            this.drawDividerLines(),
            isCrashed) {
                if (currentX += canvas.width * .01,
                currentY -= canvas.height * .01,
                currentX > canvas.width || currentY < -planeGif.offsetHeight) {
                    planeGif.style.display = "none";
                    cancelAnimationFrame(animationId);
                    return
                }
            } else
                currentX = planeStartX + (planeStopX - planeStartX) * progress + oscillatingOffsetX,
                currentY = planeStartY - (planeStartY - planeEndY) * Math.pow(progress, 2) + oscillatingOffsetY;
            planeGif.style.display = "block";
            this.updatePlaneGifPosition()
        },
        drawRotatingBackground: function() {
            ctx.save();
            ctx.translate(0, canvas.height);
            ctx.rotate(rotationAngle);
            const numLines = 30
              , lineLength = Math.hypot(canvas.width, canvas.height)
              , maxLineWidth = window.innerWidth < 768 ? 40 : 60;
            for (let i = 0; i < numLines; i++) {
                ctx.beginPath();
                const gradient = ctx.createLinearGradient(0, 0, lineLength, 0);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${i % 2 ? .01 : .05})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, ${i % 2 ? .01 : .05})`);
                ctx.strokeStyle = gradient;
                ctx.moveTo(0, 0);
                ctx.lineTo(lineLength, 0);
                ctx.lineWidth = maxLineWidth;
                ctx.stroke();
                ctx.rotate(Math.PI * 2 / numLines)
            }
            ctx.restore();
            isCrashed || (rotationAngle += .002)
        },
        drawCenteredGradientBackground: function() {
            if (!isCrashed) {
                const centerX = canvas.width / 2
                  , centerY = canvas.height / 2
                  , gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.width / 2);
                gradient.addColorStop(0, "rgba(128, 0, 128, 0.7)");
                gradient.addColorStop(.3, "rgba(128, 0, 128, 0.3)");
                gradient.addColorStop(.6, "rgba(128, 0, 128, 0.1)");
                gradient.addColorStop(1, "rgba(128, 0, 128, 0)");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height)
            }
        },
        drawDynamicLines: function(progress, oscillatingOffsetY, oscillatingOffsetX) {
            if (!isCrashed) {
                const planeWidth = canvas.width * .1
                  , planeHeight = canvas.height * .1;
                currentX = planeStartX + (planeStopX - planeStartX) * progress - planeWidth / 2 + oscillatingOffsetX;
                currentY = planeStartY - (planeStartY - planeEndY) * Math.pow(progress, 2) + oscillatingOffsetY + planeHeight / 2;
                const controlX = (planeStartX + currentX) / 2
                  , controlY = planeStartY + planeHeight / 2 + 2;
                ctx.save();
                const bottomLineY = canvas.height - 10;
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, bottomLineY);
                ctx.clip();
                ctx.beginPath();
                ctx.moveTo(planeStartX - planeWidth / 2, planeStartY + planeHeight / 2);
                ctx.quadraticCurveTo(controlX, controlY, currentX, currentY);
                ctx.lineTo(currentX, planeStartY + planeHeight / 2);
                ctx.lineTo(planeStartX - planeWidth / 2, planeStartY + planeHeight / 2);
                ctx.closePath();
                ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(planeStartX - planeWidth / 2, planeStartY + planeHeight / 2);
                ctx.quadraticCurveTo(controlX, controlY, currentX, currentY);
                ctx.lineWidth = 3;
                ctx.strokeStyle = "red";
                ctx.stroke();
                ctx.closePath();
                ctx.restore()
            }
        },
        drawMovingDots: function() {
            const dotSize = window.innerWidth < 768 ? 2 : 3
              , spacing = window.innerWidth < 768 ? 100 : 150
              , bottomY = canvas.height - 10;
            ctx.beginPath();
            for (let x = canvas.width + dotOffset; x > -canvas.width; x -= spacing)
                ctx.arc(x, bottomY, dotSize, 0, Math.PI * 2);
            ctx.fillStyle = "white";
            ctx.fill();
            ctx.closePath();
            reachedCenter && !isCrashed && (dotOffset -= 2,
            dotOffset <= -spacing && (dotOffset = 0))
        },
        drawVerticalDots: function() {
            const dotSize = window.innerWidth < 768 ? 2 : 3
              , spacing = 80
              , leftX = 10;
            ctx.beginPath();
            for (let y = -canvas.height + verticalDotOffset; y < canvas.height; y += spacing)
                ctx.arc(leftX, y, dotSize, 0, Math.PI * 2);
            ctx.fillStyle = "white";
            ctx.fill();
            ctx.closePath();
            reachedCenter && !isCrashed && (verticalDotOffset += 2,
            verticalDotOffset >= spacing && (verticalDotOffset = 0))
        },
        drawDividerLines: function() {
            const bottomDividerY = canvas.height - 20
              , leftDividerX = 20;
            ctx.beginPath();
            ctx.moveTo(0, bottomDividerY);
            ctx.lineTo(canvas.width, bottomDividerY);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#888";
            ctx.stroke();
            ctx.closePath();
            ctx.beginPath();
            ctx.moveTo(leftDividerX, 0);
            ctx.lineTo(leftDividerX, canvas.height);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#888";
            ctx.stroke();
            ctx.closePath()
        },
        updatePlaneGifPosition: function() {
            const {width: planeWidth, height: planeHeight} = this.getPlaneDimensions();
            planeGif.style.left = `${currentX - planeWidth / 2}px`;
            planeGif.style.top = `${currentY - planeHeight / 2}px`;
            planeGif.style.width = `${planeWidth}px`;
            planeGif.style.height = `${planeHeight}px`
        },
        drawStaticScene: function() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.drawDividerLines();
            this.drawMovingDots(!1);
            this.drawVerticalDots(!1);
            const {width: planeWidth, height: planeHeight} = this.getPlaneDimensions();
            ctx.drawImage(planeGif, planeStartX - planeWidth / 2, planeStartY - planeHeight / 2, planeWidth, planeHeight)
        },
        crashPlane: function() {
            isCrashed = !0;
            planeGif.style.display = "none";
            startTime = performance.now()
        },
        resetPlaneToStart: function() {
            isCrashed = !1;
            cancelAnimationFrame(animationId);
            this.updatePlaneStartPosition();
            planeGif.style.display = "none";
            animationId = null;
            this.drawStaticScene()
        },
        RunningCanvas: function() {
            this.startAnimation()
        },
        BeforeUnloadHandler: function(event) {
            event.preventDefault();
            event.returnValue = !0
        }
    }
};
let canvas = "", ctx = "", planeGif = "", animationId, isCrashed = !1, reachedCenter = !1, currentX, currentY, dotOffset = 0, verticalDotOffset = 0, rotationAngle = 0, planeStartX, planeStartY, planeStopX, planeEndY;
const duration = 5e3;
let startTime;
const OrderState = {
    EMPTY: 0,
    QUEUED: 1,
    PROCESSING: 2,
    SUBMITTED: 3
}
  , GameState = {
    OPEN: 0,
    CASHOUT: 1,
    CLOSED: 2
};
Vue.filter("formatempty", function(value) {
    return value === 0 || value === null || value === undefined || value == "--" ? "" : value === "" ? null : numeral(value).format("0,0")
});
window.channelId = "9001";
const timerMixin = {
    data: function() {
        return {
            message: "Hi Timer",
            timeLimit: 20,
            timePassed: 0,
            timeLeft: this.timeLimit,
            timerInterval: null,
            remainingPathColor: "green",
            isRunning: !1
        }
    },
    methods: {
        OnTimesUp: function() {
            clearInterval(this.timerInterval)
        },
        SyncTimer: function(timeLimit, progress) {
            const self = this;
            let initialValue = timeLimit;
            if (timeLimit == 0) {
                self.timeLeft = 0;
                self.OnTimesUp();
                return
            }
            ControllerName == "BetProGames" && progress > 0 && (timeLimit = Math.round(timeLimit / (100 - progress) * 100));
            (exgameid == 9030 || exgameid == 9035) && timeLimit >= 16 && (timeLimit = timeLimit - 5);
            let elapsed = Math.round(progress / 100 * timeLimit);
            if (this.timerInterval !== null)
                if (Math.abs(elapsed - self.timePassed) >= 2)
                    self.OnTimesUp();
                else
                    return;
            self.timePassed = elapsed;
            self.timeLimit = timeLimit;
            self.timeLeft = self.timeLimit - self.timePassed;
            this.timerInterval = setInterval( () => {
                self.timePassed += 1;
                self.timeLeft = self.timeLimit - self.timePassed;
                self.setCircleDasharray();
                self.setRemainingPathColor(self.timeLeft);
                self.timeLeft === 0 && self.OnTimesUp();
                var ElementExGames = document.getElementById("Exgamesprogress");
                if (ElementExGames != null && ElementExGames != undefined) {
                    let percentageDecrease = (initialValue - self.timeLeft) / initialValue * 100;
                    ElementExGames.style.width = percentageDecrease + "%"
                }
            }
            , 1e3)
        },
        setCircleDasharray: function() {
            const circleDasharray = `${(this.calculateTimeFraction() * 283).toFixed(0)} 283`;
            var pathrem = document.getElementById("base-timer-path-remaining");
            pathrem != null && pathrem != undefined && pathrem.setAttribute("stroke-dasharray", circleDasharray)
        },
        setRemainingPathColor: function() {
            const {alert, warning, info} = {
                info: {
                    color: "green"
                },
                warning: {
                    color: "orange",
                    threshold: 10
                },
                alert: {
                    color: "red",
                    threshold: 5
                }
            };
            var btp = document.getElementById("base-timer-path-remaining");
            btp != null && btp != undefined && (this.timeLeft <= alert.threshold ? (btp.classList.remove(warning.color),
            btp.classList.add(alert.color)) : this.timeLeft <= warning.threshold ? (btp.classList.remove(info.color),
            btp.classList.add(warning.color)) : (btp.classList.remove(alert.color),
            btp.classList.add(info.color)))
        },
        calculateTimeFraction: function() {
            const rawTimeFraction = this.timeLeft / this.timeLimit;
            return rawTimeFraction - 1 / this.timeLimit * (1 - rawTimeFraction)
        },
        formatTime: function(time) {
            const minutes = Math.floor(time / 60);
            let seconds = time % 60;
            return seconds < 10 && (seconds = `0${seconds}`),
            `${minutes}:${seconds}`
        },
        reset: function() {
            this.timePassed = 0;
            this.timeLeft = this.timeLimit;
            this.setCircleDasharray();
            this.setRemainingPathColor(this.timeLeft)
        },
        ticktps: function(limit) {
            this.timeLeft = limit;
            this.setCircleDasharray();
            this.setRemainingPathColor(this.timeLeft)
        },
        tick: function(limit, progress) {
            let elapsed = Math.round(progress / 100 * limit);
            this.timeLimit = limit;
            this.timePassed = elapsed;
            this.timeLeft = limit - elapsed;
            this.setCircleDasharray();
            this.setRemainingPathColor(this.timeLeft)
        }
    }
};
if (document.querySelector("#ExgamesDiv") !== null) {
    var mixinsArray = [timerMixin];
    try {
        typeof casinoSnapsMixin != "undefined" && mixinsArray.push(casinoSnapsMixin)
    } catch (e) {}
    try {
        typeof crashGameMixin != "undefined" && mixinsArray.push(crashGameMixin)
    } catch (e) {}
    new Vue({
        el: "#ExgamesDiv",
        mixins: mixinsArray,
        data: {
            traceEnabled: !1,
            backColor: "227,248,255",
            layColor: "255,205,204",
            plusFlash: "0,178,255",
            minusFlash: "255,122,127",
            MyAvOrders: "MyAvOrd",
            ExMatched: [],
            snapshot: [],
            positions: [],
            results: [],
            shortresults: [],
            AviatorListAdv: [],
            mainroundid: 0,
            previousRoundId: 0,
            Order: {
                render: !1,
                RoundId: 1,
                MarketId: 1,
                price: 1.01,
                size: 0,
                side: "B",
                selectionId: 0,
                ChannelId: 1,
                isFixOdds: !1,
                runnerName: "",
                working: !1,
                BetType: "",
                error: "",
                Selection: 0
            },
            channelId: null,
            sToken: null,
            casinoUrl: null,
            activeChipIndex: null,
            ActiveChipsOrders: [],
            TempChipsOrders: [],
            RouletteSubmit: !1,
            chips: [{
                img: "/img/chip1.svg",
                value: typeof stake1 != "undefined" ? stake1 : 0
            }, {
                img: "/img/chip2.svg",
                value: typeof stake2 != "undefined" ? stake2 : 0
            }, {
                img: "/img/chip3.svg",
                value: typeof stake3 != "undefined" ? stake3 : 0
            }, {
                img: "/img/chip4.svg",
                value: typeof stake4 != "undefined" ? stake4 : 0
            }]
        },
        created: function() {
            this.channelId = exgameid;
            this.sToken = typeof token != "undefined" ? token : null;
            this.casinoUrl = typeof casinoUrl != "undefined" ? casinoUrl : null;
            exgameid != "" && exgameid != undefined && (typeof CasSck != "undefined" ? CasSck === 1 && this.Connect() : (this.FetchSnapshot(),
            ControllerName == "BetProGames" ? (this.FetchShortResults(),
            setInterval(this.FetchSnapshot, 800),
            setInterval(this.FetchShortResults, 7e3)) : setInterval(this.FetchSnapshot, 2e3),
            setInterval(this.FetchOrders, 1500)));
            document.addEventListener("visibilitychange", this.handleVisibilityChange)
        },
        computed: {
            isConnected: function() {
                if (typeof CasSck != "undefined")
                    return CasSck === 0 ? !0 : this.isSignalRConnected
            },
            currentMarketId: function() {
                return this.snapshot.channel.game.id
            },
            RouletteOrders: function() {
                return this.ActiveChipsOrders.reduce( (sum, order) => sum + (order.size || 0), 0)
            }
        },
        watch: {
            timeLeft: function(newVal) {
                (exgameid == 9030 || exgameid == 9035) && (this.snapshot.channel.status == 4 && this.ResetRoulette(),
                this.snapshot.channel.status == 1 && newVal <= 1 && this.RouletteSubmit == !1 && this.ActiveChipsOrders.length > 0 && (this.RouletteSubmit = !0,
                this.SubmitRouletteOrders()));
                exgameid == 9080 && (this.snapshot.channel.status !== 1 || this.snapshot.channel.status == 1 && newVal <= 1) && this.TempChipsOrders.length !== 0 && (this.TempChipsOrders = [],
                this.CloseBetSlip())
            }
        },
        methods: {
            Trace: function(message) {
                this.traceEnabled && console.log(message)
            },
            FetchSnapshot: function() {
                var self = this
                  , qs = "/api/" + ControllerName + "/" + exgameid + "/snapshot";
                $.getJSON(qs, function(catalog) {
                    self.SetPositions(catalog)
                })
            },
            ImageUrl: function(baseurl, number) {
                return number == "NOT AVAILABLE" ? ControllerName == "BetProGames" ? baseurl + "omaha_back.svg" : baseurl + "omaha_back_bf.svg" : baseurl + number + ".svg"
            },
            PlaceOrder: function() {
                if (!this.Order.working) {
                    var self = this
                      , qs = /api/ + ControllerName;
                    if (ControllerName == "BetProGames" && (qs = /api/ + "v2/Orders/game/" + exgameid),
                    typeof CasSck != "undefined" && CasSck === 1 && !this.isSignalRConnected) {
                        self.Order.error = "Server not available. Try again.";
                        return
                    }
                    this.Order.working = !0;
                    $.ajax({
                        type: "POST",
                        url: qs,
                        data: JSON.stringify(self.Order),
                        contentType: "application/json; charset=utf-8",
                        success: function() {
                            self.Order.working = !1;
                            self.CloseBetSlip();
                            self.HideBetSlip()
                        },
                        error: function(data) {
                            self.Order.working = !1;
                            self.Order.error = data.responseJSON.title
                        }
                    })
                }
            },
            CalcPL: function() {
                price = parseFloat(this.Order.price);
                size = parseFloat(this.Order.size);
                var orderPrice = this.IsAggregateOrder ? price : price - 1;
                this.Order.side === "B" ? (profit = orderPrice * size,
                liable = size) : (profit = size,
                liable = orderPrice * size);
                this.Order.profit = numeral(profit).format("0,0[.]00");
                this.Order.liable = numeral(liable).format("0,0[.]00")
            },
            ShowBetSlipMobile: function() {
                $("#betSlipMobile").on("shown.bs.modal", function() {
                    $("#bet-size-m").trigger("focus")
                });
                $("#betSlipMobile").modal("show")
            },
            HideBetSlip: function() {
                $("#betSlipMobile").modal("hide")
            },
            ShowBetSlip: function(runner, side, gameid, ControlIndex, marketid) {
                this.Order.error = "";
                this.Order.render = !1;
                this.Order.side = side;
                var price = 0;
                this.Order.size = "";
                this.Order.size === 0 && (this.Order.size = this.GetDefaultStake());
                switch (ControlIndex) {
                case 1:
                    price = side.toLowerCase() === "b" ? runner.bestAvailableToBackPrices[0].value : runner.bestAvailableToLayPrices[0].value;
                    break;
                case 2:
                    price = side.toLowerCase() === "b" ? runner.bestAvailableToBackPrices[1].value : runner.bestAvailableToLayPrices[1].value;
                    break;
                case 3:
                    price = side.toLowerCase() === "b" ? runner.bestAvailableToBackPrices[2].value : runner.bestAvailableToLayPrices[2].value
                }
                price !== undefined && price !== null && (price = parseFloat(price),
                this.Order.MarketId = marketid,
                this.Order.price = price,
                this.Order.RoundId = gameid,
                this.Order.ChannelId = exgameid,
                this.Order.runnerName = runner.name,
                this.Order.identity = GetDeviceIdentity(),
                this.Order.BetType = side.toLowerCase() === "b" ? "Back" : "Lay",
                this.Order.Selection = runner.id,
                this.CalcPL(),
                side === "L" ? ($("#Place-Order,#PrInc,#PrDec").removeClass("btn-info"),
                $("#Place-Order,#PrInc,#PrDec").addClass("btn-danger"),
                $("#bet-slip-head").removeClass("bg-primary"),
                $("#bet-slip-head").addClass("bg-danger")) : ($("#Place-Order,#PrInc,#PrDec").addClass("btn-info"),
                $("#Place-Order,#PrInc,#PrDec").removeClass("btn-danger"),
                $("#bet-slip-head").removeClass("bg-danger"),
                $("#bet-slip-head").addClass("bg-primary")),
                IsMobile() ? this.ShowBetSlipMobile() : (setTimeout(function() {
                    $("#bet-size").focus()
                }, 150),
                this.Order.render = !0))
            },
            CloseBetSlip: function() {
                this.Order.render = !1
            },
            HideBetSlip: function() {
                $("#betSlipMobile").modal("hide")
            },
            FetchOrders: function() {
                const self = this;
                let qs = /api/ + ControllerName + "/Orders?id=" + exgameid + "&Roundid=" + self.mainroundid;
                ControllerName == "BetProGames" && (qs = /api/ + "v2/Orders/Orders?roundId=" + self.mainroundid);
                $.getJSON(qs, function(Result) {
                    Result.orders == null || Result.orders == undefined ? (self.ExMatched = [],
                    self.positions = []) : (self.positions = Result.position,
                    self.ExMatched = Result.orders)
                })
            },
            FetchResults: function() {
                const self = this
                  , qs = /api/ + ControllerName + "/Results?Channelid=" + exgameid;
                $.getJSON(qs, function(Result) {
                    self.results = Result
                })
            },
            FetchShortResults: function() {
                const self = this
                  , qs = /api/ + ControllerName + "/ShortResults?Channelid=" + exgameid;
                $.getJSON(qs, function(Result) {
                    self.shortresults = Result
                })
            },
            SetSignalRposition: function() {
                var self = this;
                _.each(self.snapshot.channel.game.markets.market, function(MainMarket) {
                    _.each(MainMarket.selections.selection, function(Runner) {
                        var Finded = _.find(self.positions, function(PosData) {
                            return Runner.id == PosData.selectionId
                        });
                        Finded != undefined && (Runner.position = Finded.position,
                        Runner.lose = Finded.lose)
                    })
                })
            },
            SetPositions: function(SNPSHT) {
                var currentRoundId;
                let loader = document.getElementById("loadingexgames");
                loader != null && (loader.style.display = "none");
                let body = document.getElementById("Excardbody");
                body != null && (body.style.display = "block");
                let self = this;
                if (_.each(SNPSHT.channel.game.markets.market, function(MainMarket) {
                    _.each(MainMarket.selections.selection, function(Runner) {
                        var Finded = _.find(self.positions, function(PosData) {
                            return Runner.id == PosData.selectionId
                        });
                        Finded != undefined && (Runner.position = Finded.position,
                        Runner.lose = Finded.lose)
                    })
                }),
                self.snapshot = SNPSHT,
                self.mainroundid = SNPSHT.channel.game.id,
                (SNPSHT.channel.id == 1444116 || SNPSHT.channel.id == 1444126) && this.UpdateDerby(SNPSHT),
                typeof CasSck != "undefined" && CasSck === 1) {
                    let ElementExGames = document.getElementById("Exgamesprogress");
                    ElementExGames != null && ElementExGames != undefined ? self.snapshot.channel.game.markets.market[0].status === 0 && self.SyncTimer(SNPSHT.channel.game.bettingWindowTime, SNPSHT.channel.game.bettingWindowPercentageComplete) : self.SyncTimer(SNPSHT.channel.game.bettingWindowTime, SNPSHT.channel.game.bettingWindowPercentageComplete)
                } else if (ControllerName == "BetProGames")
                    self.ticktps(SNPSHT.channel.game.bettingWindowTime),
                    self.tick(SNPSHT.channel.game.bettingWindowTime, SNPSHT.channel.game.bettingWindowPercentageComplete);
                else {
                    let elem = document.getElementById("Exgamesprogress");
                    elem != null && elem != undefined && (elem.style.width = SNPSHT.channel.game.bettingWindowPercentageComplete + "%",
                    self.tick(SNPSHT.channel.game.bettingWindowTime, SNPSHT.channel.game.bettingWindowPercentageComplete))
                }
                if (exgameid == "9015") {
                    var overlay = document.getElementById("overlay")
                      , elDiceOne = document.getElementById("dice1")
                      , elDiceTwo = document.getElementById("dice2")
                      , elDiceThree = document.getElementById("dice3");
                    if (elDiceOne != null && elDiceOne != undefined) {
                        var value1 = parseInt(SNPSHT.channel.game.gameData[0].totalValue)
                          , value2 = parseInt(SNPSHT.channel.game.gameData[1].totalValue)
                          , value3 = parseInt(SNPSHT.channel.game.gameData[2].totalValue);
                        isValidDiceValue(value1) && isValidDiceValue(value2) && isValidDiceValue(value3) ? (currentRoundId = SNPSHT.channel.game.id,
                        currentRoundId !== self.previousRoundId && document.visibilityState == "visible" && (self.previousRoundId = currentRoundId,
                        overlay.style.display = "none",
                        removeAllShowClassesWithDelay(elDiceOne),
                        removeAllShowClassesWithDelay(elDiceTwo),
                        removeAllShowClassesWithDelay(elDiceThree),
                        setTimeout(function() {
                            elDiceOne.classList.add("show" + value1);
                            elDiceTwo.classList.add("show" + value2);
                            elDiceThree.classList.add("show" + value3)
                        }, 2e3))) : overlay.style.display = "flex"
                    }
                    function removeAllShowClassesWithDelay(element) {
                        for (var i = 1; i <= 6; i++)
                            element.classList.remove("show" + i)
                    }
                    function isValidDiceValue(value) {
                        return !isNaN(value) && value >= 1 && value <= 6
                    }
                }
                if (exgameid == "9030") {
                    if (SNPSHT.channel.status == 1) {
                        const rouletteWheel = document.getElementById("rouletteWheel")
                          , currentRotationMod = currentRotation % 360
                          , degreesToRotate = (360 - currentRotationMod) % 360;
                        rouletteWheel.style.transition = "transform 2s ease";
                        currentRotation += degreesToRotate;
                        rouletteWheel.style.transform = `rotate(${currentRotation}deg)`;
                        setTimeout( () => {
                            isSpinning = !1
                        }
                        , 2e3)
                    }
                    if (SNPSHT.channel.status == 2 && SNPSHT.channel.game.gameData[0].totalValue != "" && SNPSHT.channel.game.gameData[0].totalValue != null) {
                        if (isSpinning)
                            return;
                        const input = parseInt(SNPSHT.channel.game.gameData[0].totalValue)
                          , rouletteWheel = document.getElementById("rouletteWheel")
                          , numberOrder = [0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26]
                          , index = numberOrder.indexOf(input)
                          , numberCount = numberOrder.length
                          , degreesPerNumber = 360 / numberCount
                          , targetDegrees = index * degreesPerNumber
                          , currentRotationMod = currentRotation % 360
                          , degreesToRotate = 360 - targetDegrees - currentRotationMod;
                        rouletteWheel.style.transition = `transform 11s ease-out`;
                        currentRotation += degreesToRotate + 1440;
                        rouletteWheel.style.transform = `rotate(${currentRotation}deg)`;
                        isSpinning = !0
                    }
                    if ((SNPSHT.channel.status === 3 || SNPSHT.channel.status === 4) && SNPSHT.channel.game.gameData[0].totalValue != "" && SNPSHT.channel.game.gameData[0].totalValue != null) {
                        const input = parseInt(SNPSHT.channel.game.gameData[0].totalValue)
                          , numberOrder = [0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26]
                          , index = numberOrder.indexOf(input)
                          , numberCount = numberOrder.length
                          , degreesPerNumber = 360 / numberCount
                          , targetDegrees = index * degreesPerNumber
                          , currentRotationMod = currentRotation % 360
                          , degreesToRotate = 360 - targetDegrees - currentRotationMod;
                        rouletteWheel.style.transition = "none";
                        currentRotation += degreesToRotate;
                        rouletteWheel.style.transform = `rotate(${currentRotation}deg)`
                    }
                }
                if (exgameid == "9035") {
                    if (SNPSHT.channel.status == 1 && setTimeout( () => {
                        isSpinning = !1
                    }
                    , 2e3),
                    SNPSHT.channel.status == 2 && SNPSHT.channel.game.gameData[0].totalValue != "" && SNPSHT.channel.game.gameData[0].totalValue != null) {
                        if (isSpinning)
                            return;
                        const Maininput = SNPSHT.channel.game.gameData[0].totalValue
                          , input = Maininput.includes(",") ? Maininput.split(",").pop() : Maininput
                          , rouletteWheel = document.getElementById("rouletteWheel")
                          , numberOrder = ["1", "20", "1", "2", "1", "x7", "1", "10", "2", "1", "5", "2", "1", "2", "1", "2", "1", "5", "40", "1", "10", "1", "2", "1", "5", "2", "1", "20", "1", "2", "1", "x2", "1", "10", "2", "1", "5", "2", "1", "2", "1", "2", "1", "5", "40", "1", "10", "1", "2", "1", "5", "2"]
                          , findIndices = (arr, num) => arr.reduce( (acc, val, index) => (val === num && acc.push(index),
                        acc), [])
                          , indices = findIndices(numberOrder, input);
                        if (indices.length === 0)
                            return;
                        randomIndex = indices[Math.floor(Math.random() * indices.length)];
                        const numberCount = numberOrder.length
                          , degreesPerNumber = 360 / numberCount
                          , targetDegrees = randomIndex * degreesPerNumber
                          , currentRotationMod = currentRotation % 360
                          , degreesToRotate = 360 - targetDegrees - currentRotationMod
                          , totalDegreesToRotate = degreesToRotate + 1080;
                        rouletteWheel.style.transition = `transform 8s ease-out`;
                        currentRotation += totalDegreesToRotate;
                        rouletteWheel.style.transform = `rotate(${currentRotation}deg)`;
                        isSpinning = input === "x7" || input === "x2" ? !1 : !0
                    }
                    if ((SNPSHT.channel.status === 3 || SNPSHT.channel.status === 4) && SNPSHT.channel.game.gameData[0].totalValue != "" && SNPSHT.channel.game.gameData[0].totalValue != null) {
                        const Maininput = SNPSHT.channel.game.gameData[0].totalValue
                          , input = Maininput.includes(",") ? Maininput.split(",").pop() : Maininput
                          , numberOrder = ["1", "20", "1", "2", "1", "x7", "1", "10", "2", "1", "5", "2", "1", "2", "1", "2", "1", "5", "40", "1", "10", "1", "2", "1", "5", "2", "1", "20", "1", "2", "1", "x2", "1", "10", "2", "1", "5", "2", "1", "2", "1", "2", "1", "5", "40", "1", "10", "1", "2", "1", "5", "2"];
                        let index = numberOrder.indexOf(input);
                        randomIndex != 0 && (index = randomIndex);
                        const numberCount = numberOrder.length
                          , degreesPerNumber = 360 / numberCount
                          , targetDegrees = index * degreesPerNumber
                          , currentRotationMod = currentRotation % 360
                          , degreesToRotate = 360 - targetDegrees - currentRotationMod;
                        rouletteWheel.style.transition = `transform 1s ease-out`;
                        currentRotation += degreesToRotate;
                        rouletteWheel.style.transform = `rotate(${currentRotation}deg)`
                    }
                }
                if (exgameid == "9085") {
                    if (SNPSHT.channel.status == 1 && setTimeout( () => {
                        isSpinning = !1
                    }
                    , 2e3),
                    SNPSHT.channel.status == 2 && SNPSHT.channel.game.gameData[0].totalValue != "" && SNPSHT.channel.game.gameData[0].totalValue != null && !document.hidden) {
                        if (isSpinning)
                            return;
                        const BGSound = document.getElementById("CointossSound");
                        isCTMuted || document.hidden || (BGSound.volume = .2,
                        BGSound.play());
                        const coin = document.getElementById("CTcoin")
                          , randomDuration = Math.random() * 3 + 2
                          , userInput = SNPSHT.channel.game.gameData[0].totalValue;
                        coin.style.animation = "none";
                        coin.style.background = userInput === "1" ? "#ff4081" : "#4081ff";
                        coin.textContent = userInput === "1" ? "H" : "T";
                        setTimeout( () => {
                            coin.style.animation = `flipWithOneZoom ${randomDuration}s linear`;
                            const shuffleInterval = setInterval( () => {
                                coin.textContent = coin.textContent === "H" ? "T" : "H",
                                coin.style.background = coin.textContent === "H" ? "#ff4081" : "#4081ff"
                            }
                            , 100)
                              , winnerCheckInterval = setInterval( () => {
                                let isWinner = !1;
                                if (SNPSHT.channel.game.markets.market.forEach(MMarket => {
                                    MMarket.selections.selection.forEach(Runner => {
                                        Runner.runnerStatus === "WINNER" && (isWinner = !0)
                                    }
                                    )
                                }
                                ),
                                isWinner) {
                                    clearInterval(shuffleInterval);
                                    coin.style.animation = "none";
                                    SNPSHT.channel.game.gameData[0].totalValue === "1" ? (coin.textContent = "H",
                                    coin.style.background = "#ff4081") : (coin.textContent = "T",
                                    coin.style.background = "#4081ff");
                                    clearInterval(winnerCheckInterval);
                                    return
                                }
                            }
                            , 100);
                            setTimeout( () => {
                                clearInterval(shuffleInterval),
                                userInput === "1" ? (coin.textContent = "H",
                                coin.style.background = "#ff4081") : (coin.textContent = "T",
                                coin.style.background = "#4081ff"),
                                coin.style.animation = "",
                                clearInterval(winnerCheckInterval)
                            }
                            , randomDuration * 1e3)
                        }
                        );
                        isSpinning = !0
                    }
                    if ((SNPSHT.channel.status === 3 || SNPSHT.channel.status === 4) && SNPSHT.channel.game.gameData[0].totalValue != "" && SNPSHT.channel.game.gameData[0].totalValue != null) {
                        const coin = document.getElementById("CTcoin")
                          , userInput = SNPSHT.channel.game.gameData[0].totalValue;
                        userInput === "1" ? (coin.textContent = "H",
                        coin.style.background = "#ff4081") : (coin.textContent = "T",
                        coin.style.background = "#4081ff")
                    }
                }
            },
            LoadImgs: function(id, src, className="", retryCount=5, retryDelay=200) {
                const div = document.getElementById(id);
                if (!div) {
                    retryCount > 0 && setTimeout( () => {
                        this.LoadImgs(id, src, className, retryCount - 1, retryDelay)
                    }
                    , retryDelay);
                    return
                }
                if (!div.querySelector("img")) {
                    const img = document.createElement("img");
                    img.src = src;
                    className && (img.className = className);
                    div.appendChild(img)
                }
            },
            DerbyPreImages: function() {
                this.LoadImgs("SkyDerb", "/img/Derby/sky.png");
                this.LoadImgs("BgDerb", "/img/Derby/background.png");
                this.LoadImgs("startline", "/img/Derby/Line.png");
                this.LoadImgs("horse0", "/img/Derby/green-still.png", "Derb-horse0");
                this.LoadImgs("horse1", "/img/Derby/red-still.png", "Derb-horse1");
                this.LoadImgs("horse2", "/img/Derby/blue-still.png", "Derb-horse2");
                this.LoadImgs("horse3", "/img/Derby/yellow-still.png", "Derb-horse3");
                this.LoadImgs("finishline", "/img/Derby/finishline.svg")
            },
            UpdateDerby: function(gameData) {
                let self = this;
                self.DerbyPreImages();
                let suitMap = {
                    Spades: 0,
                    Hearts: 1,
                    Clubs: 2,
                    Diamonds: 3
                };
                if (self.UpdateDerbyMsj(gameData.channel.game.round),
                gameData.channel.game.round == 1 || gameData.channel.game.round == 2) {
                    self.ResetDerby();
                    return
                }
                gameData.channel.game.gameData.forEach(function(obj) {
                    if (obj.name && suitMap.hasOwnProperty(obj.name) && obj.status === "WINNER") {
                        var mappedValue = suitMap[obj.name];
                        self.FinishDerby(mappedValue)
                    }
                });
                var hasWinner = gameData.channel.game.gameData.some(function(obj) {
                    return obj.name && suitMap.hasOwnProperty(obj.name) && obj.status === "WINNER"
                })
                  , suits = gameData.channel.game.gameData.filter(function(obj) {
                    return obj.name && suitMap.hasOwnProperty(obj.name) && (obj.status === "IN_PLAY" || obj.status === "LOSER" || obj.status === "WINNER")
                }).map(function(obj) {
                    var segment = 0, j;
                    if (obj.property && obj.property.length)
                        for (j = 0; j < obj.property.length; j++)
                            if (obj.property[j].name === "Segment") {
                                segment = parseInt(obj.property[j].value, 10);
                                break
                            }
                    return {
                        name: obj.name,
                        segment: segment,
                        value: suitMap[obj.name],
                        status: obj.status
                    }
                })
                  , isMobile = window.innerWidth < 500;
                return setTimeout(function() {
                    var i, suit, percent;
                    for (hasWinner || self.AnimateDerbyEnvironment(),
                    i = 0; i < suits.length; i++)
                        suit = suits[i],
                        percent = 0,
                        isMobile ? percent = suit.status === "WINNER" ? 100 : Math.min(suit.segment / 33 * 50, 50) : suit.segment > 0 && (percent = Math.min(suit.segment / 33 * 70, 70)),
                        self.MoveDerby(suit.value, percent)
                }, 2e3),
                suits
            },
            remainingDerby: function(suitIndex) {
                var self = this, suitMap = {
                    Spades: 0,
                    Hearts: 1,
                    Clubs: 2,
                    Diamonds: 3
                }, placeMap = {
                    "1": "1st",
                    "2": "2nd",
                    "3": "3rd",
                    "4": "4rth"
                }, suits = self.snapshot.channel.game.gameData.filter(function(obj) {
                    return obj.name && suitMap.hasOwnProperty(obj.name) && (obj.status === "IN_PLAY" || obj.status === "LOSER" || obj.status === "WINNER")
                }).map(function(obj) {
                    var segment = 0, place = "1st", j, prop;
                    if (obj.property && obj.property.length)
                        for (j = 0; j < obj.property.length; j++)
                            prop = obj.property[j],
                            prop.name === "Segment" ? segment = parseInt(prop.value, 10) : prop.name === "Place" && (place = placeMap[prop.value] || prop.value);
                    return {
                        name: obj.name,
                        segment: segment,
                        pos: place,
                        value: suitMap[obj.name],
                        status: obj.status
                    }
                }), suit;
                return typeof suitIndex != "number" ? null : (suit = suits.find(function(s) {
                    return s.value === suitIndex
                }),
                !suit) ? null : suit.status === "WINNER" ? "WINNER" : typeof suit.segment != "number" ? null : suit.pos + ", " + (32 - suit.segment) + " to go"
            },
            MoveDerby: function(selectedHorse, percent) {
                var horse = document.querySelector(".Derb-horse" + selectedHorse);
                if (!horse) {
                    console.warn("Horse .Derb-horse" + selectedHorse + " not found");
                    return
                }
                var line = horse.previousElementSibling
                  , targetPercent = Math.max(0, Math.min(percent, 100))
                  , currentPercent = parseFloat(horse.style.left || "0");
                targetPercent > currentPercent && (horse.style.left = targetPercent + "%",
                line && (line.classList.remove("animate"),
                line.offsetWidth,
                line.classList.add("animate")))
            },
            AnimateDerbyEnvironment: function() {
                var finishLine = document.querySelector(".Derb-startline"), fence, flags, i, horse, src;
                finishLine && finishLine.classList.add("reveal");
                const container = document.querySelector(".Derb-track-container");
                for (container && container.classList.remove("paused"),
                fence = document.querySelector(".Derb-fence"),
                fence && fence.classList.add("fence-animate"),
                flags = document.querySelector(".Derb-flags"),
                flags && flags.classList.add("flag-animate"),
                i = 0; i < 4; i++)
                    horse = document.querySelector(".Derb-horse" + i),
                    horse && (src = horse.getAttribute("src"),
                    src && src.includes("-still.png") && horse.setAttribute("src", src.replace("-still.png", ".gif")))
            },
            FinishDerby: function(winnerIndex) {
                var track = document.getElementById("raceTrack")
                  , finishLine = document.querySelector(".Derb-finishline")
                  , trackWidth = track.clientWidth;
                setTimeout(function() {
                    var interval;
                    finishLine.classList.add("reveal");
                    var winningHorse = document.querySelector(".Derb-horse" + winnerIndex)
                      , horseWidth = winningHorse.offsetWidth
                      , finishX = trackWidth - horseWidth;
                    winningHorse.style.left = finishX + "px";
                    interval = setInterval(function() {
                        var horseRect = winningHorse.getBoundingClientRect()
                          , horseCenter = horseRect.left + horseRect.width / 2
                          , finishRect = finishLine.getBoundingClientRect()
                          , finishCenter = finishRect.left + finishRect.width / 2;
                        if (Math.abs(horseCenter - finishCenter) < 5) {
                            clearInterval(interval);
                            track.classList.add("flash");
                            track.classList.add("paused");
                            for (let i = 0; i < 4; i++) {
                                let horse = document.querySelector(".Derb-horse" + i);
                                if (horse) {
                                    let src = horse.getAttribute("src");
                                    src && src.indexOf(".gif") !== -1 && horse.setAttribute("src", src.replace(".gif", "-still.png"))
                                }
                            }
                            setTimeout(function() {
                                track.classList.remove("flash")
                            }, 1200)
                        }
                    }, 50)
                }, 50)
            },
            ResetDerby: function() {
                for (let i = 0; i < 4; i++) {
                    let horse = document.querySelector(".Derb-horse" + i);
                    if (horse) {
                        horse.style.transition = "none";
                        horse.style.left = "0px";
                        void horse.offsetWidth;
                        horse.style.transition = "";
                        horse.previousElementSibling && horse.previousElementSibling.classList.remove("animate");
                        let src = horse.getAttribute("src");
                        src && src.indexOf(".gif") !== -1 && horse.setAttribute("src", src.replace(".gif", "-still.png"))
                    }
                }
                document.querySelector(".Derb-finishline").classList.remove("reveal");
                document.querySelector(".Derb-startline").classList.remove("reveal");
                document.querySelector(".Derb-fence").classList.remove("fence-animate");
                document.querySelector(".Derb-flags").classList.remove("flag-animate")
            },
            DerbWinner: function(rnr) {
                var self = this;
                return self.snapshot.channel.game.gameData.some(function(obj) {
                    return obj.name !== "Cards" && obj.name === rnr && obj.status === "WINNER"
                })
            },
            DerbImgUrl: function(targetNumber) {
                for (var fields, j, field, prop, k, values, m, num, self = this, cardsObject = null, gameData = self.snapshot.channel.game.gameData, i = 0; i < gameData.length; i++)
                    if (gameData[i].name === "Cards") {
                        cardsObject = gameData[i];
                        break
                    }
                if (!cardsObject || !cardsObject.property)
                    return null;
                for (fields = ["Handicap", "Used", "Current"],
                j = 0; j < fields.length; j++) {
                    for (field = fields[j],
                    prop = null,
                    k = 0; k < cardsObject.property.length; k++)
                        if (cardsObject.property[k].name === field) {
                            prop = cardsObject.property[k];
                            break
                        }
                    if (prop && prop.value)
                        for (values = prop.value.split(","),
                        m = 0; m < values.length; m++)
                            if (num = parseInt(values[m].trim(), 10),
                            num === targetNumber)
                                return "/img/Cards/card_simple_" + targetNumber + ".svg"
                }
                return null
            },
            DerbHCImgUrl: function(targetNumber) {
                for (var fields, j, field, prop, k, values, m, num, self = this, cardsObject = null, gameData = self.snapshot.channel.game.gameData, i = 0; i < gameData.length; i++)
                    if (gameData[i].name === "Cards") {
                        cardsObject = gameData[i];
                        break
                    }
                if (!cardsObject || !cardsObject.property)
                    return null;
                for (fields = ["Handicap"],
                j = 0; j < fields.length; j++) {
                    for (field = fields[j],
                    prop = null,
                    k = 0; k < cardsObject.property.length; k++)
                        if (cardsObject.property[k].name === field) {
                            prop = cardsObject.property[k];
                            break
                        }
                    if (prop && prop.value)
                        for (values = prop.value.split(","),
                        m = 0; m < values.length; m++)
                            if (num = parseInt(values[m].trim(), 10),
                            num === targetNumber)
                                return "/img/Cards/card_simple_" + targetNumber + ".svg"
                }
                return null
            },
            DerbActImgUrl: function(targetNumber) {
                for (var fields, j, field, prop, k, values, m, num, self = this, cardsObject = null, gameData = self.snapshot.channel.game.gameData, i = 0; i < gameData.length; i++)
                    if (gameData[i].name === "Cards") {
                        cardsObject = gameData[i];
                        break
                    }
                if (!cardsObject || !cardsObject.property)
                    return null;
                for (fields = ["Current"],
                j = 0; j < fields.length; j++) {
                    for (field = fields[j],
                    prop = null,
                    k = 0; k < cardsObject.property.length; k++)
                        if (cardsObject.property[k].name === field) {
                            prop = cardsObject.property[k];
                            break
                        }
                    if (prop && prop.value)
                        for (values = prop.value.split(","),
                        m = 0; m < values.length; m++)
                            if (num = parseInt(values[m].trim(), 10),
                            num === targetNumber)
                                return "/img/Cards/card_simple_" + targetNumber + ".svg"
                }
                return null
            },
            UpdateDerbyMsj: function(round) {
                var self = this, titleEl = document.getElementById("gameMsgTitle"), textEl = document.getElementById("gameMsgText"), newTitle, newText;
                titleEl != null && (newTitle = "",
                newText = "",
                round === 1 ? (newTitle = "Betting Round",
                newText = "The race is going to start soon. Place your bets!!") : round === 2 ? (newTitle = "Betting Round",
                newText = "The handicap has been created and the race is about to start. Place your bets!") : (newTitle = "Round " + (round - 2),
                newText = "Three cards will be drawn from each Deck.!"),
                self.snapshot.channel.game.gameData.forEach(function(obj) {
                    obj.name && obj.status === "WINNER" && (newTitle = obj.name + " Horse Wins",
                    newText = "Game Over! Settlement in progress.")
                }),
                titleEl.textContent !== newTitle || textEl.textContent !== newText) && (titleEl.textContent = newTitle,
                textEl.textContent = newText,
                document.querySelector(".game-message-cardderbyracing").classList.add("show"),
                setTimeout(function() {
                    document.querySelector(".game-message-cardderbyracing").classList.remove("show")
                }, 5e3))
            },
            SetOrderSize: function(newSize) {
                this.Order.size = newSize
            },
            IncreaseOrderSize: function(increment) {
                document.getElementsByClassName("points").disabled = !0;
                this.Order.size === "" && (this.Order.size = 0);
                this.Order.size += increment;
                document.getElementsByClassName("points").disabled = !1
            },
            MarketTab: function(tabname) {
                tabname == "RESULTS" && this.FetchResults();
                LastTab = tabname;
                for (var tablinks, tabclr = tabname + "tab", tabcontent = document.getElementsByClassName("tabcontent"), i = 0; i < tabcontent.length; i++)
                    tabcontent[i].style.display = "none";
                for (tablinks = document.getElementsByClassName("tablink"),
                i = 0; i < tablinks.length; i++)
                    tablinks[i].style.backgroundColor = "",
                    tablinks[i].style.display = "inline-block";
                document.getElementById(tabname).style.display = "contents";
                document.getElementById(tabclr).style.backgroundColor = "black";
                document.getElementById(tabclr).style.color = "white"
            },
            ShowMarketRules: function(Name) {
                Name == "1444080" ? Name = "1444074" : Name == "1444082" ? Name = "1444077" : Name == "1444089" ? Name = "1444086" : Name == "1444096" ? Name = "1444093" : Name == "9005" ? Name = "9001" : Name == "9040" ? Name = "9022" : Name == "1444126" && (Name = "1444116");
                var file = "/" + Name + ".html";
                $("#modalMarketRules").modal("show");
                $.get(file, function(data) {
                    $("#modalMarketRules .modal-body").html(data)
                })
            },
            Toastertoshow: function(mess, value) {
                toastr.options = {
                    closeButton: !1,
                    debug: !1,
                    newestOnTop: !1,
                    progressBar: !1,
                    positionClass: "toast-top-center",
                    preventDuplicates: !1,
                    onclick: null,
                    showDuration: "300",
                    hideDuration: "1000",
                    timeOut: "5000",
                    extendedTimeOut: "1000",
                    showEasing: "swing",
                    hideEasing: "linear",
                    showMethod: "fadeIn",
                    hideMethod: "fadeOut"
                };
                const status = {
                    1: "success",
                    2: "error",
                    3: "warning",
                    4: "info"
                }[value];
                toastr[status](mess)
            },
            RouletteBetSlipHC: function(Name, marketid) {
                if (this.ActiveChipsOrders || (this.ActiveChipsOrders = []),
                this.activeChipIndex == null || this.activeChipIndex == undefined) {
                    alert("Please select chip to place order");
                    return
                }
                const newOrder = {};
                newOrder.side = "B";
                const chipValue = this.chips[parseInt(this.activeChipIndex)].value;
                newOrder.size = parseInt(chipValue);
                newOrder.MarketId = marketid;
                newOrder.price = parseFloat(2);
                newOrder.RoundId = marketid;
                newOrder.ChannelId = exgameid;
                newOrder.runnerName = Name;
                newOrder.identity = GetDeviceIdentity();
                newOrder.BetType = "Back";
                newOrder.Selection = 1;
                newOrder.Metadata = Name;
                this.ActiveChipsOrders.push(newOrder)
            },
            haveRouOrder: function(ID) {
                return this.ActiveChipsOrders.some(order => order.Selection === ID)
            },
            haveRouSideOrder: function(Name) {
                return this.ActiveChipsOrders.some(order => order.runnerName === Name)
            },
            getChipImage: function(ID) {
                const order = this.ActiveChipsOrders.find(o => o.Selection === ID);
                if (order) {
                    const orderSize = order.size
                      , chip = this.chips.find(c => parseInt(c.value) === orderSize);
                    if (chip)
                        return chip.img
                }
                return null
            },
            getSideChipImage: function(Name) {
                const order = this.ActiveChipsOrders.find(o => o.runnerName === Name);
                if (order) {
                    const orderSize = order.size
                      , chip = this.chips.find(c => parseInt(c.value) === orderSize);
                    if (chip)
                        return chip.img
                }
                return null
            },
            ChipSelector: function(index) {
                this.activeChipIndex = index;
                const chipValue = this.chips[index].value;
                console.log("Selected chip value:", chipValue)
            },
            isChipActive: function(index) {
                return this.activeChipIndex === index
            },
            getColorClass: function(number) {
                if (exgameid == 9030) {
                    if ([1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36].includes(Number(number)))
                        return "col-Red";
                    if ([2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35].includes(Number(number)))
                        return "col-Black";
                    if (Number(number) == 0)
                        return "col-Green"
                }
                return ""
            },
            UnDoRoulette: function() {
                this.ActiveChipsOrders && this.ActiveChipsOrders.length > 0 && this.ActiveChipsOrders.pop()
            },
            ResetRoulette: function() {
                this.ActiveChipsOrders = [];
                this.RouletteSubmit = !1
            },
            highlight: function(numbers) {
                numbers.forEach(num => {
                    const element = document.getElementById(`value-${num}`);
                    element && element.classList.add("DivHighlight")
                }
                )
            },
            removeHighlight: function(numbers) {
                numbers.forEach(num => {
                    const element = document.getElementById(`value-${num}`);
                    element && element.classList.remove("DivHighlight")
                }
                )
            },
            RunnerValue: function(SID) {
                let totalSize = 0;
                return Array.isArray(this.ActiveChipsOrders) && this.ActiveChipsOrders.forEach(order => {
                    order.Selection === SID && (totalSize += order.size ? parseInt(order.size) : 0)
                }
                ),
                totalSize >= 1e3 ? totalSize / 1e3 + "k" : totalSize
            },
            SideRunnerValue: function(Name) {
                let totalSize = 0;
                return Array.isArray(this.ActiveChipsOrders) && this.ActiveChipsOrders.forEach(order => {
                    order.runnerName === Name && (totalSize += order.size ? parseInt(order.size) : 0)
                }
                ),
                totalSize >= 1e3 ? totalSize / 1e3 + "k" : totalSize
            },
            IsRuunerWinner: function(SID) {
                var self = this;
                const input = parseInt(self.snapshot.channel.game.gameData[0].totalValue);
                if (isNaN(input))
                    return !1;
                if (self.snapshot.channel.status !== 2) {
                    if (!self.snapshot || !self.snapshot.channel || !self.snapshot.channel.game || !self.snapshot.channel.game.markets || !self.snapshot.channel.game.markets.market || !self.snapshot.channel.game.markets.market[0] || !self.snapshot.channel.game.markets.market[0].selections)
                        return !1;
                    if (!isNaN(SID) && parseInt(SID) === input || SID === "COL1" && (input - 1) % 3 == 0 || SID === "COL2" && (input - 2) % 3 == 0 || SID === "COL3" && input % 3 == 0 || SID === "1 - 12" && input >= 1 && input <= 12 || SID === "13 - 24" && input >= 13 && input <= 24 || SID === "25 - 36" && input >= 25 && input <= 36 || SID === "EVEN" && input % 2 == 0 || SID === "ODD" && input % 2 != 0 || SID === "RED" && [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36].includes(input) || SID === "BLACK" && [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35].includes(input) || SID === "1 - 18" && input >= 1 && input <= 18 || SID === "19 - 36" && input >= 19 && input <= 36)
                        return !0
                }
                return !1
            },
            SubmitRouletteOrders: function() {
                var self = this
                  , qs = "/api/v2/Orders/game/R/" + exgameid;
                if (CasSck === 1 && !this.isSignalRConnected) {
                    self.ResetRoulette();
                    console.log("Socket Disconnected. Try Again");
                    return
                }
                self.Toastertoshow("Submitting Orders", 1);
                const consolidatedOrders = {};
                this.ActiveChipsOrders.forEach(order => {
                    const key = `${order.Metadata}`;
                    consolidatedOrders[key] || (consolidatedOrders[key] = {
                        error: "",
                        render: !1,
                        side: "b",
                        size: 0,
                        MarketId: order.MarketId,
                        price: order.price,
                        RoundId: order.RoundId,
                        ChannelId: exgameid,
                        runnerName: order.runnerName,
                        identity: order.identity,
                        BetType: "Back",
                        Selection: order.Selection,
                        Metadata: order.Metadata
                    });
                    consolidatedOrders[key].size += order.size
                }
                );
                const newConsolidatedOrders = Object.values(consolidatedOrders);
                if (newConsolidatedOrders.length === 0) {
                    self.Toastertoshow("No orders to submit", 2);
                    return
                }
                $.ajax({
                    type: "POST",
                    url: qs,
                    data: JSON.stringify(newConsolidatedOrders),
                    contentType: "application/json; charset=utf-8",
                    success: function() {
                        self.Toastertoshow("Orders Placed Successfully", 1)
                    },
                    error: function(data) {
                        self.ResetRoulette();
                        console.error("Error submitting orders:", data);
                        data.responseJSON && data.responseJSON.title ? self.Toastertoshow(data.responseJSON.title, 2) : self.Toastertoshow("An error occurred while submitting orders.", 2)
                    }
                })
            },
            playBGSoundWithRetry: function() {
                const soundControl = document.getElementById("AvxSoundcontrol")
                  , BGSound = document.getElementById("TpbgSound");
                isBgMuted ? (BGSound.volume = .2,
                BGSound.play(),
                soundControl.classList.remove("fa-volume-off"),
                soundControl.classList.add("fa-volume-up"),
                isBgMuted = !1,
                console.log("Sound play")) : (BGSound.pause(),
                soundControl.classList.remove("fa-volume-up"),
                soundControl.classList.add("fa-volume-off"),
                isBgMuted = !0,
                console.log("Sound pause"))
            },
            handleVisibilityChange: function() {
                const BGSound = document.getElementById("TpbgSound")
                  , crashSound = document.getElementById("crashSound");
                BGSound != null && (BGSound.volume = .1,
                document.hidden ? (BGSound.pause(),
                (crashSound != null || crashSound != undefined) && crashSound.pause()) : isBgMuted || BGSound.play().catch( () => {}
                ))
            },
            formatDate: function(dateString) {
                if (!dateString)
                    return "";
                const date = new Date(dateString);
                return date.toLocaleString("en-US", {
                    month: "2-digit",
                    day: "numeric",
                    hour: "2-digit",
                    minute: "2-digit"
                })
            },
            showTab: function(tabIndex) {
                document.getElementById("simple-tabpanel-2").style.visibility = "visible";
                lotactivetab = tabIndex === 1 ? 9 : tabIndex === 2 ? 80 : tabIndex === 3 ? 700 : value;
                randomIndex = tabIndex;
                this.TempChipsOrders = [];
                this.CloseBetSlip();
                const containers = document.querySelectorAll(".market-odds-container");
                containers.forEach( (container, index) => {
                    index < tabIndex ? (container.classList.add("show-content"),
                    container.classList.remove("hide-content")) : (container.classList.remove("show-content"),
                    container.classList.add("hide-content"))
                }
                )
            },
            LotteryBetslip: function(row, value) {
                lotactivetab == 9 && this.SaveSingleOrder(row, value);
                lotactivetab == 80 && this.SaveDoubleOrder(row, value);
                lotactivetab == 700 && this.SaveTripleOrder(row, value)
            },
            SaveSingleOrder: function(runnerName, value) {
                if (runnerName = runnerName + "-",
                runnerName.startsWith("Single-")) {
                    const existingSingleOrder = this.TempChipsOrders.find(order => order.runnerName === runnerName && order.Selection === 1);
                    if (existingSingleOrder)
                        existingSingleOrder.Metadata = value;
                    else {
                        const newOrder = {
                            Selection: 1,
                            runnerName: runnerName,
                            Metadata: value
                        };
                        this.TempChipsOrders.push(newOrder)
                    }
                }
                const singleOrder = this.TempChipsOrders.find(order => order.runnerName.startsWith("Single-"));
                if (singleOrder) {
                    const combinedMetadata = `${singleOrder.Metadata}`;
                    this.LotOrderGenerator("Single", combinedMetadata, 9)
                }
            },
            SaveDoubleOrder: function(runnerName, value) {
                if (runnerName = runnerName + "-",
                runnerName.startsWith("Single-")) {
                    const existingSingleOrder = this.TempChipsOrders.find(order => order.runnerName === runnerName && order.Selection === 2);
                    if (existingSingleOrder)
                        existingSingleOrder.Metadata = value;
                    else {
                        const newOrder = {
                            Selection: 2,
                            runnerName: runnerName,
                            Metadata: value
                        };
                        this.TempChipsOrders.push(newOrder)
                    }
                } else if (runnerName.startsWith("Double-")) {
                    const existingSingleOrder = this.TempChipsOrders.find(order => order.Selection === 2 && order.runnerName.startsWith("Single-"));
                    if (!existingSingleOrder) {
                        alert("Please add Single cards first!");
                        return
                    }
                    const existingDoubleOrder = this.TempChipsOrders.find(order => order.runnerName.startsWith(runnerName) && order.Selection === 2);
                    if (existingDoubleOrder)
                        existingDoubleOrder.Metadata = value,
                        console.log(`Updated Double order:`, existingDoubleOrder);
                    else {
                        const newDoubleOrder = {
                            Selection: 2,
                            runnerName: runnerName,
                            Metadata: value
                        };
                        this.TempChipsOrders.push(newDoubleOrder);
                        console.log(`Added new Double order:`, newDoubleOrder)
                    }
                }
                const singleOrder = this.TempChipsOrders.find(order => order.runnerName.startsWith("Single-"))
                  , doubleOrder = this.TempChipsOrders.find(order => order.runnerName.startsWith("Double-"));
                if (singleOrder && doubleOrder) {
                    const combinedMetadata = `${singleOrder.Metadata}${doubleOrder.Metadata}`;
                    this.LotOrderGenerator("Double", combinedMetadata, 80)
                }
            },
            SaveTripleOrder: function(runnerName, value) {
                if (runnerName = runnerName + "-",
                runnerName.startsWith("Single-")) {
                    const existingSingleOrder = this.TempChipsOrders.find(order => order.runnerName === runnerName && order.Selection === 3);
                    if (existingSingleOrder)
                        existingSingleOrder.Metadata = value;
                    else {
                        const newOrder = {
                            Selection: 3,
                            runnerName: runnerName,
                            Metadata: value
                        };
                        this.TempChipsOrders.push(newOrder)
                    }
                } else if (runnerName.startsWith("Double-")) {
                    const existingSingleOrder = this.TempChipsOrders.find(order => order.Selection === 3 && order.runnerName.startsWith("Single-"));
                    if (!existingSingleOrder) {
                        alert("Please add Single cards first!");
                        return
                    }
                    const existingDoubleOrder = this.TempChipsOrders.find(order => order.runnerName === runnerName && order.Selection === 3);
                    if (existingDoubleOrder)
                        existingDoubleOrder.Metadata = value;
                    else {
                        const newDoubleOrder = {
                            Selection: 3,
                            runnerName: runnerName,
                            Metadata: value
                        };
                        this.TempChipsOrders.push(newDoubleOrder)
                    }
                } else if (runnerName.startsWith("Triple-")) {
                    const existingSingleOrder = this.TempChipsOrders.find(order => order.Selection === 3 && order.runnerName.startsWith("Single-"))
                      , existingDoubleOrder = this.TempChipsOrders.find(order => order.Selection === 3 && order.runnerName.startsWith("Double-"));
                    if (!existingSingleOrder || !existingDoubleOrder) {
                        alert("Please add both Single and Double cards first!");
                        return
                    }
                    const existingTripleOrder = this.TempChipsOrders.find(order => order.runnerName === runnerName && order.Selection === 3);
                    if (existingTripleOrder)
                        existingTripleOrder.Metadata = value,
                        console.log(`Updated Triple order:`, existingTripleOrder);
                    else {
                        const newTripleOrder = {
                            Selection: 3,
                            runnerName: runnerName,
                            Metadata: value
                        };
                        this.TempChipsOrders.push(newTripleOrder)
                    }
                }
                const singleOrder = this.TempChipsOrders.find(order => order.runnerName.startsWith("Single-"))
                  , doubleOrder = this.TempChipsOrders.find(order => order.runnerName.startsWith("Double-"))
                  , tripleOrder = this.TempChipsOrders.find(order => order.runnerName.startsWith("Triple-"));
                if (singleOrder && doubleOrder && tripleOrder) {
                    const combinedMetadata = `${singleOrder.Metadata}${doubleOrder.Metadata}${tripleOrder.Metadata}`;
                    this.LotOrderGenerator("Triple", combinedMetadata, 700)
                }
            },
            LotOrderGenerator: function(row, value, Odds) {
                var self = this, NewName = row + "-" + value, price;
                this.Order.error = "";
                this.Order.render = !1;
                this.Order.side = "B";
                price = 0;
                this.Order.size = "";
                this.Order.size === 0 && (this.Order.size = this.GetDefaultStake());
                price = parseFloat(Odds);
                this.Order.MarketId = self.snapshot.channel.game.id;
                this.Order.price = price;
                this.Order.RoundId = self.snapshot.channel.game.id;
                this.Order.ChannelId = exgameid;
                this.Order.runnerName = NewName;
                this.Order.Metadata = value;
                this.Order.identity = GetDeviceIdentity();
                this.Order.BetType = "Back";
                this.Order.Selection = lotactivetab === 9 ? 1 : lotactivetab === 80 ? 2 : lotactivetab === 700 ? 3 : 0;
                this.CalcPL();
                IsMobile() ? this.ShowBetSlipMobile() : (setTimeout(function() {
                    $("#bet-size").focus()
                }, 150),
                this.Order.render = !0)
            },
            LotOrderPlaced: function(value) {
                return this.TempChipsOrders.some(order => order.runnerName + order.Metadata === value)
            },
            playBGSoundCT: function() {
                const soundControl = document.getElementById("AvxSoundcontrol");
                isCTMuted ? (soundControl.classList.remove("fa-volume-off"),
                soundControl.classList.add("fa-volume-up"),
                isCTMuted = !1) : (soundControl.classList.remove("fa-volume-up"),
                soundControl.classList.add("fa-volume-off"),
                isCTMuted = !0)
            }
        }
    })
}
let currentRotation = 1500
  , isSpinning = !1
  , randomIndex = 0
  , isBgMuted = !0
  , isCTMuted = !0
  , lotactivetab = 9;
Vue.filter("format", function(value) {
    return value === 0 || value === null || value === undefined ? "" : value === "" ? null : numeral(value).format("0,0")
});
Vue.filter("formatchip", function(stake) {
    return stake < 1e3 ? stake : (stake / 1e3).toFixed() + "k"
});
$(document).ready(function() {
    $("#IsDisplayOn").click(function() {
        $(this).attr("disabled", !0);
        noSleep.enable()
    })
});
